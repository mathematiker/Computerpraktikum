gap> Q:=Quiver(5,[[5,4,"d"],[4,3,"c"],[3,2,"b"],[2,1,"a"]]);
<quiver with 5 vertices and 4 arrows>
gap> I:=NthPowerOfArrowIdeal(kQ,2);
[ (1)*a^2, (1)*a*s, (1)*b^2, (1)*b*g, (1)*g*a, (1)*g*s, (1)*s*b, (1)*s*g ]
gap>  kQ := PathAlgebra(Rationals,Q);
<Rationals[<quiver with 5 vertices and 4 arrows>]>
gap> I:=NthPowerOfArrowIdeal(kQ,2);
[ (1)*d*c, (1)*c*b, (1)*b*a ]
gap> A:=kQ/I;
<Rationals[<quiver with 5 vertices and 4 arrows>]/
<two-sided ideal in <Rationals[<quiver with 5 vertices and 4 arrows>]>, 
  (3 generators)>>
  
  
  
  
  
gap> projectives := IndecProjectiveModules(A);
%das sind die unzerlegbaren projektiven Moduln
[ <[ 1, 0, 0, 0, 0 ]>, <[ 1, 1, 0, 0, 0 ]>, <[ 0, 1, 1, 0, 0 ]>, 
  <[ 0, 0, 1, 1, 0 ]>, <[ 0, 0, 0, 1, 1 ]> ]
%e_1A,e_2A,...
gap> proj1 := projectives[1];
<[ 1, 0, 0, 0, 0 ]>
gap> Display(proj1);
<Module over <Rationals[<quiver with 5 vertices and 4 arrows>]/
<two-sided ideal in <Rationals[<quiver with 5 vertices and 4 arrows>]>, 
  (3 generators)>> with dimension vector [ 1, 0, 0, 0, 0 
 ]> and linear maps given by
for arrow d:
[ [  0 ] ]
for arrow c:
[ [  0 ] ]
for arrow b:
[ [  0 ] ]
for arrow a:
[ [  0 ] ]
%M=e_1A
gap> proj3:=projectives[3];
<[ 0, 1, 1, 0, 0 ]>
gap> Display(proj3);
<Module over <Rationals[<quiver with 5 vertices and 4 arrows>]/
<two-sided ideal in <Rationals[<quiver with 5 vertices and 4 arrows>]>, 
  (3 generators)>> with dimension vector [ 0, 1, 1, 0, 0 
 ]> and linear maps given by
for arrow d:
[ [  0 ] ]
for arrow c:
[ [  0 ] ]
for arrow b:
[ [  1 ] ]
for arrow a:
[ [  0 ] ]
%M=e_2A
gap> RadicalOfModule(proj1);
<[ 0, 0, 0, 0, 0 ]>
%Radikale von e_1A
gap> RadicalOfModule(proj3);
<[ 0, 1, 0, 0, 0 ]>
%Radikale von e_3A





%injektive und einfache Moduln

gap> injectives:=IndecInjectiveModules(A);
[ <[ 1, 1, 0, 0, 0 ]>, <[ 0, 1, 1, 0, 0 ]>, <[ 0, 0, 1, 1, 0 ]>, 
  <[ 0, 0, 0, 1, 1 ]>, <[ 0, 0, 0, 0, 1 ]> ]
gap> simples:=SimpleModules(A);
[ <[ 1, 0, 0, 0, 0 ]>, <[ 0, 1, 0, 0, 0 ]>, <[ 0, 0, 1, 0, 0 ]>, 
  <[ 0, 0, 0, 1, 0 ]>, <[ 0, 0, 0, 0, 1 ]> ]

%Sockel von injektiven Modul inj1

gap> inj1:=injectives[1];
<[ 1, 1, 0, 0, 0 ]>
gap> SocleOfModule(inj1);
<[ 1, 0, 0, 0, 0 ]>
